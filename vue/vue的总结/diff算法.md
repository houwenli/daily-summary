# 虚拟dom和diff算法

## 虚拟dom

虚拟dom是什么，为什么使用虚拟dom

### 虚拟dom是什么

虚拟dom实际上是真实dom的映射，实际上是一个js对象，运用一定的规则（这个规则可以自己定义）

比如，可以便于我们用js语言来描述dom结构

```js
<div id="app">
  <p class="text">TXM to SFM</p>
</div>

// => 可以转化为以下结构
{
  tag: 'div',
  props: {
    id: 'app'
  },
  chidren: [
    {
      tag: 'p',
      props: {
        className: 'text'
      },
      chidren: [
        'TXM to SFM'
      ]
    }
  ]
}
```

### 为什么使用虚拟dom

现在框架中都不是操作底层的api去修改页面了，比如vue，我们只用关心数据的修改，但是假如没有虚拟dom，每次有数据修改势必会引发dom更新，如果频繁更新dom就会造成一定的性能问题

使用虚拟dom会在更新真实dom前收集所有的变化，也就是说数据发生变化时我们并不会操作真实dom，而是产生一个新的dom，然后新旧dom做diff，diff过程中按照一定的算法只更新变化的部分，从而达到局部最小化更新的效果

## 整个dom diff 过程

- 用js 模拟dom树（虚拟dom）
- 用虚拟dom渲染出真实dom（render）
- 如果有更新就会产生新的虚拟dom，然后找出两个虚拟dom的差异（diff）
- 把差异的部分回写到真实dom上（patch）

## diff算法

当我们在比较两颗虚拟dom树时，如果采用普通的对比方法，新树的每个节点都要和老树的每个节点做比较，这样以3层结构，1000个节点来说，渲染一次需要比较1000\*1000\*1000这就很恐怖了

所以前端框架的diff约定了两个原则：只做同层的比较，如果节点type变了就不再比较了，直接把新的节点patch就好了，这样比较起来时间复杂度就降低了，1000个节点，只用比较1000次就好了

这样其实也有一些问题，比如我们有5个节点ABCDE，下次变成了EABCD，如果我们按照type比较的话就会造成，5个节点都会重新渲染一下，实际上只要移动一下E元素的位置就好了，这样虽然diff简单了，dom操作会变得比较多，而dom操作也是很花费时间的

### 简单diff

我们先来看看简单diff算法，**多节点diff算法是为了尽量多的复用节点，通过移动节点来代替创建**，所以前端框架会让开发者指定key，通过key判断节点是不是只是发生了移动，从而直接服用

所以新 vnode 数组的每个节点我们都要找下在旧 vnode 数组中有没有对应 key 的，有的话就移动到新的位置，没有的话再创建新的。

实现如下

- 循环新的vnode，定义一个lastindex
- 循环旧的vnode
- 根据key查找，如果在旧的vnode找到就可以直接复用，渲染之后，移动到合适位置
- 如果没在旧的vnode中就直接新增
- 最后把旧的vnode在新的vnode中没有的节点删除

但是这个算法有一个问题就是，如果我们老的节点是ABCDE，新的节点是ABECD，在我们渲染之后就会对ECD3个节点都调整位置，怎么优化呢

### 双端diff算法

实现如下

- 双端diff算法是指有4个指针，新旧vnode头尾各有一个指针
- 然后使用头头，尾尾，头尾，尾头的方式进行比较
- 如果找到，就按一定的顺序插入
- 如果比较失败就在旧的vnode中查找
- 找到的话就移动元素到新元素的startIndex之后，同时把旧vnode的对应元素置为undefined
- 如果还是没找到就新增元素到startIndex之后
- 任意一个vnode指针重合就结束查找，此时如果新的vnode有多余就直接插入，旧的vnode有多余就把响应元素删除
