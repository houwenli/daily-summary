# Monorepo 的进化

从单仓库巨石应用，到多仓库多模块应用，最后转向单仓库多模块应用

- 单仓库巨石应用（Monolith）：这种结构在项目初期比较常见，因为一切都在一个仓库中，所以便于管理和部署。但随着项目的增长，这种结构的缺点逐渐显现，包括但不限于构建时间的增长、代码冲突的频繁、以及难以维护
- 多仓库多模块应用（MultiRepo）：为了克服巨石应用的缺点，项目可能被拆分成多个较小的模块，每个模块使用单独的仓库管理。这样做可以提高模块的独立性，便于团队并行开发和维护，但也带来了新的挑战，比如跨仓库的依赖管理、版本同步问题以及工作流程的复杂性增加。
- 单仓库多模块应用（MonoRepo）：为了解决多仓库管理带来的问题，有些团队和项目转向使用单仓库来管理多个模块。这种方式可以简化跨模块的依赖管理，提高代码共享的效率，并且可以统一构建和测试流程。不过，MonoRepo 也有其挑战，比如需要更精细的权限控制、大规模仓库的性能优化等。

每种方法都有其适用场景，没有绝对的好坏。例如，小到中型项目可能会更倾向于使用 Monolith 或 MultiRepo，而大型项目和大型团队可能会从 MonoRepo 中获益，尤其是当需要频繁地跨模块协作时。在选择最适合自己项目的策略时，需要权衡各种因素，包括团队规模、项目复杂度、构建和测试流程的需求等。

## Monorepo 使用场景

- 大型团队协作： 当大型团队在多个相关项目上协作时，Monorepo 可以简化协作流程。由于所有项目都位于同一仓库中，团队成员可以轻松访问和修改跨项目的代码，促进了团队间的沟通和合作。
- 微服务架构： 在微服务架构中，系统由多个小型、独立服务组成。使用 Monorepo 可以方便地管理这些服务的代码，确保服务之间的兼容性，并简化跨服务的重构和共享代码。
- 多平台/多产品开发 对于跨多个平台（如 Web、iOS、Android）或多个产品线开发的公司，Monorepo 可以提供一个统一的代码基础，使得共享通用库、组件和工具变得简单，同时保持构建和发布流程的一致性。
- 共享库和组件 在开发涉及多个共享库或可重用组件的项目时，Monorepo 允许开发人员轻松更新和维护这些共享资源。这有助于提高代码重用率，降低维护成本。
- 统一的工具和流程： 对于希望统一代码风格、构建工具、测试框架和部署流程的团队，Monorepo 提供了一个共同的基础设施，有助于标准化开发实践，简化新成员的入职过程。
- 原子性更改和重构： 当需要对跨多个项目或模块的代码进行重构或更新时，Monorepo 使得这些更改可以作为一个原子提交进行，降低了部署和回滚的复杂性

# 为什么 pnpm 能实现 Monorepo

pnpm 在安装依赖包时，主要经历了以下三个步骤：解析依赖、获取依赖以及链接依赖

- 解析依赖（Dependency Resolution）
在这个阶段，pnpm 需要确定要安装的每个依赖包的具体版本。它会查看项目的 package.json 文件以及任何现有的锁文件（如 pnpm-lock.yaml），来决定哪些版本的包需要被安装。解析依赖时，pnpm 会遵循以下规则：
 - 版本兼容性：基于 package.json 中指定的版本范围，选择与之兼容的最新版本。
 - 锁文件：如果存在锁文件，pnpm 会优先使用锁文件中锁定的版本，以确保依赖的一致性和项目的可重现性。

- 获取依赖（Fetching Dependencies） 一旦确定了需要安装的依赖版本，pnpm 将开始获取这些依赖包。这个过程包括以下几个步骤：
  - 检查全局存储：pnpm 首先会检查其全局存储中是否已经存在所需版本的依赖包。如果已经存在，就不需要从远程仓库下载，直接重用即可。
  - 下载缺失的依赖：对于全局存储中不存在的依赖，pnpm 会从 npm 或其他配置的仓库下载它们。下载的依赖包会被存储在全局存储中，以便将来重用
  - 内容寻址存储：pnpm 使用内容寻址方式来存储依赖包，即`根据包内容的哈希值`来确定存储路径。这确保了相同内容的包在全局存储中只有一份副本，节省了磁盘空间。

- 链接依赖（Linking Dependencies） 获取依赖包之后，pnpm 需要将这些依赖链接到项目的 node_modules 目录中，使得项目能够使用这些依赖。这个步骤涉及
  - 创建硬链接和符号链接：对于每个依赖包，pnpm 会在项目的 node_modules 目录中创建指向全局存储中相应包的硬链接。如果是包内部的依赖，还可能创建符号链接来保持正确的依赖结构。
  - pnpm 通过构建一个虚拟的 node_modules 目录来模拟传统的嵌套依赖结构，但实际上依赖之间是通过符号链接相连的。这样做既保持了 npm 生态的兼容性，又避免了重复的依赖副本和深层嵌套的问题
  - 通过这种链接方式，pnpm 确保了项目只能访问其直接依赖的包，防止了对未声明依赖的意外访问，提高了项目的稳定性和安全性。
